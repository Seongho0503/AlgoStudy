이 문제  핵심 
1) abc 밖에 없음
2) 최소길이 2이상인 팰린드롬 이면 안된다 aa bb cc

1 ) 처음 a 가 올 경우 -> 다음 자리에 올 수 있는 문자는 b 와 c 
( a가 올 경우 aa 가 되어 팰린드롬이 되버린다. )

2 ) a b 이후에는 c 밖에 못온다 ( a 가 올 경우 aba 로 팰린드롬, b 가 올 경우 bb 로 팰린드롬 )


3) abc 나 acb 이후에 올 수 있는 문자는 다시 a 뿐이다. (나머지 경우는 모두 팰린드롬이 된다 ) 
 
 -> 팰린드롬을 안 만들기 위한 방법은 'abc', 'acb'처럼 3개의 문자가 사용이 됐을 때, 만들어지지가 않는다.

​
 aa,bb,cc와 같이 연속된 문자가 나오면 안된다
a,b,c의 개수를 세서 가장 많은 것의 개수와 가장 적은 것의 개수를 뺐을 때 
2보다 크면 aa와 같은 길이가 2인 펠린드롬을 만들 수 있다

​

EX ) a 3개 . b 4개 . c 5 개 --> min : 3 개 

각 개수에서 min 차감 ( 사이클 반복 )  --> abc abc abc 를 했다고 가정 

a 0개 . b 1개 . c 2개

위의 경우는 cbc 또는 ccb 또는 bcc 등 모두 팰린드롬이 되는 경우밖에 존재하지 않기 때문에 NO .

​

이후 3개의 문자 중 한개라도 개수가 2개 이상 존재하는 경우 팰린드롬이 무조건 발생하기 이 때의 경우를 "NO" 로 출력하도록 설


#1 테스트 케이스 1로 설명

str = abac 
charAt[0] = a
charAt[1] = b
charAt[2] = a
charAt[3] = c

아스키 코드에서 10진수
'a'  = 97
'b'  = 98
'c'  = 99
서로 1씩 차이남
상대적인 거니깐
a=1
b=2
c=3 로 가정함

num 배열의 크기가 3인 이유는  a,b,c 3문자 밖에 없으니깐
num은 중복확인

아까 charAt에서 모든 원소를 -a로 뺄 거임 (아스키 코드로 빼면서 a,b,c 구별하는 용도) 
charAt[0] = a    - a  = 0   'a'-'a' 서로 같은 문자 빼니깐 0나옴
charAt[1] = b    -> 1
charAt[2] = a    -> 0
charAt[3] = c    c-a는 2나옴 -> 2

정리하면

ispalin 함수(퍁린드롬인지 확인하는 함수)
거기 for문 보면
앞에서 계산한
0
1
0
2
가 num 배열의 인덱스가 됨
계산하면
num[0] = 2
num[1] = 1
num[2] = 1
가 된다


int min = 1
int max = 2
서로 1차이밖에 안나니 팰린드롬이 아니다.



  