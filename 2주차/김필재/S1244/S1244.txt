32888 2 의 경우
numbers:[3, 2, 8, 8, 8]
max:[8, 8, 8, 3, 2]

현재 숫자들 numbers를 정렬하여 최대값인 max를 만든다.
numbers의 0번째부터 시작, 끝까지
numbers의 i번째 값은 max의 i번째 값이 되어야 하므로, numbers에서 max[i]와 같은 숫자의 위치를 찾아서 교환
(여기까지는 그냥 뒤에 있는 가장 큰 수와 교환하는 것과 동일)

numbers:[3, 2, 8, 8, 8]
	             ^  ^  ^
위 테스트케이스와 같이 가장 큰 수가 여러 개 있을 경우 그중 indexOf로 가장 앞에 있는 값과 교환할 경우 82388 -> 88328이 되고, lastIndexOf로 마지막 값과 교환할 경우 82883 -> 88823이 된다. 

그래서 동일한 숫자중 어느 것과 교환할 지 max 리스트와 비교하여 정한다.
numbers:[3, 2, 8, 8, 8]
	       ^    
	       0, 1, 2, 3, 4
    max:[8, 8, 8, 3, 2]
                  ^
가장 큰 수인 8의 위치 2,3,4중에서 max에서 3이 위치한 곳은 3이므로 numbers의 인덱스3에 위치한 8과 바꾼다.

numbers:[8, 2, 8, 3, 8]
	          ^    
	       0, 1, 2, 3, 4
    max:[8, 8, 8, 3, 2]
                     ^
다음 수인 2도 마찬가지로 두 개의 8의 위치 2, 4중 4와 교환하여 88832로 만든다.

남은 횟수와 관련하여
- 맨 앞의 수부터 차례대로 교환하다 횟수가 0이되면 그대로 출력
- 이미 최대값이 완성되었는데 횟수가 남아있을 경우, 남은 횟수가 짝수일 경우 그대로 종료
- 남은 횟수가 홀수일 경우 Set을 사용하여 중복값이 있으면, 종료
- 그것도 아닐 경우 가장 마지막 두자리를 교환 후 종료
